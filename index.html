<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="theme-color" content="#0a0014" />
<title>Chasing Sunset — Core</title>
<style>
  :root{ --hot-pink:#ff2e93; --cyan:#00f5ff; --acid:#39ff14; --ink:#0e0b2b; }
  html,body{ height:100%; margin:0; background:#0a0014; overflow:hidden; font-family: ui-monospace, Menlo, Consolas, monospace; color:white; }
  #wrap{ position:fixed; inset:0; display:grid; place-items:center; z-index:1; }
  canvas{ image-rendering:auto; box-shadow:0 20px 60px #000 inset, 0 0 40px #ff2e9355, 0 0 80px #00f5ff33; border-radius:12px; background:#120024; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="480" height="270" aria-label="Chasing Sunset core game"></canvas>
</div>
<div id="startOverlay"><button id="startBtn">Start</button><div id="startTip">Avoid the cats, stay lean.</div><div id="startTip2">Move with A/D, press SPACE to pause.</div></div>

<script>
(()=>{
  // ---- setup
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; let bg=null,bgctx=null;
  const W=canvas.width,H=canvas.height,cx=W/2;
  const horizonY=H*0.45, SUN_Y=horizonY-8, SUN_R=62;
  const roadTopW=44, roadBottomW=W*0.92, LANES=3;
  const SPEED_SCALE=0.5; let pxScale = 1; const gradCache = {}; function clearGradients(){ for(const k in gradCache) delete gradCache[k]; }

  // ---- state
  const state={ time:0, normalSpeed:120, stopUntil:0, distance:0, hits:0, lives:4, gameOver:false, restartAt:0, highScores:[], started:false, paused:false, deathReason:null };
  const obstacleSpeedFactor=0.88;

  // health
  state.health=1;                      // 0..1
  const healths=[];                    // health pickups on road
  let nextHeal=2.0;                    // first spawn ~2s
  const lastCatSpawn=new Array(LANES).fill(-99);
  let lastCatLane=-1; let lastCatSpawnTime=-99;
  const lastHealthSpawn=new Array(LANES).fill(-99);
  const HEALTH_REPLENISH=0.5;          // +50% bar per pickup

  // ---- title smoke
  const titleText='Chasing Sunset'; let titleBox=null; const smoke=[]; let smokeAcc=0; const smokeRate=26;
  function spawnSmokePuff(){ if(!titleBox) return; const x=titleBox.left+Math.random()*titleBox.width; const y=titleBox.top-2; smoke.push({x,y,vx:(Math.random()-0.5)*14,vy:-(12+Math.random()*18),r:2+Math.random()*2,life:0,max:2.6+Math.random()*1.4}); }
  function updateSmoke(dt){ const dts=dt*SPEED_SCALE; smokeAcc+=smokeRate*dts; while(smokeAcc>=1){spawnSmokePuff(); smokeAcc-=1;} for(let i=smoke.length-1;i>=0;i--){const p=smoke[i]; p.life+=dts; p.x+=p.vx*dts; p.y+=p.vy*dts; p.vx*=0.98; p.vy-=6*dts; p.r+=dts*10; if(p.life>=p.max) smoke.splice(i,1);} }
  function drawSmoke(){ if(!smoke.length) return; ctx.save(); ctx.globalCompositeOperation='lighter'; for(const p of smoke){ const t=p.life/p.max, a=(1-t)*0.35, r=Math.max(1,p.r); const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r); g.addColorStop(0,`rgba(255,255,255,${a})`); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); }

  // ---- poofs
  const poofs=[]; function spawnPoof(x,y,s=1){ const count=20; for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2, sp=120+Math.random()*220; poofs.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp-60,r:(2+Math.random()*3)*(0.6+s*0.4),life:0,max:0.7+Math.random()*0.5,hue:Math.random()<0.5?330:190}); }}
  function updatePoofs(dt){ for(let i=poofs.length-1;i>=0;i--){ const p=poofs[i]; p.life+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.97; p.vy+=420*dt; p.r*=0.985; if(p.life>p.max) poofs.splice(i,1);} }
  function drawPoofs(){ if(!poofs.length) return; ctx.save(); ctx.globalCompositeOperation='lighter'; for(const p of poofs){ const t=p.life/p.max, a=(1-t)*0.8, rad=Math.max(0.5,p.r); const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,rad); const col=p.hue===330?`rgba(255,46,147,${a})`:`rgba(0,245,255,${a*0.85})`; g.addColorStop(0,col); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill(); } ctx.restore(); }

  // ---- helpers
  const clamp=(v,a,b)=>v<a?a:v>b?b:v, lerp=(a,b,t)=>a+(b-a)*t;
  const roadEdgesAtY=(y)=>{ const t=clamp((y-horizonY)/(H-horizonY),0,1); const w=lerp(roadTopW,roadBottomW,t); return {left:cx-w/2,right:cx+w/2,width:w}; };
  const laneXAtY=(lane,y)=>{ const e=roadEdgesAtY(y); const third=e.width/LANES; return e.left+third*(lane+0.5); };

  // --- tiny render + HUD + motion helpers (for code reuse)
  function fitSize(msg, basePx, maxW, fontFamily='monospace', weight='900'){
    let fs=basePx; const f=()=>`${weight} ${fs}px ${fontFamily}`; ctx.font=f();
    let m=ctx.measureText(msg); if(m.width>maxW){ fs=Math.floor(fs*(maxW/m.width)); ctx.font=f(); }
    return fs;
  }
  function drawLabel(msg, x, y, opts={}){
    const { fill='#fff', stroke=null, lw=0, shadow=null, vhs=false } = opts;
    if(vhs){ ctx.globalAlpha=0.85; ctx.fillStyle='#00ffff'; ctx.fillText(msg,x-1,y); ctx.fillStyle='#ff00ff'; ctx.fillText(msg,x+1,y); ctx.globalAlpha=1; }
    if(shadow){ ctx.shadowColor=shadow.color; ctx.shadowBlur=shadow.blur; }
    if(lw && stroke){ ctx.lineWidth=lw; ctx.strokeStyle=stroke; ctx.strokeText(msg,x,y); }
    ctx.shadowBlur=0; if(fill){ ctx.fillStyle=fill; ctx.fillText(msg,x,y); }
  }
  function panel(x,y,w,h,drawFn){
    ctx.globalAlpha=0.85; ctx.fillStyle='#00000066'; ctx.fillRect(x,y,w,h);
    ctx.globalAlpha=1; ctx.shadowColor='#00f5ff'; ctx.shadowBlur=6; ctx.strokeStyle='#00f5ff88'; ctx.lineWidth=1.5; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
    ctx.shadowBlur=0; drawFn(x,y,w,h);
  }
  function forwardStep(y, dt, baseSpeed){
    const t=clamp((y-horizonY)/(H-horizonY),0,1); const early=t<0.5?(0.4+1.2*t):1.0; return y + baseSpeed*dt*obstacleSpeedFactor*early;
  }
  function pruneOffscreen(arr){
    for(let i=arr.length-1;i>=0;i--){ const o=arr[i]; if(o.flying){ if(o.fx<-64||o.fx>W+64||o.fy<-64||o.fy>H+64) arr.splice(i,1); } else if((o.y||0)>H+64) arr.splice(i,1); }
  }

  // ---- cached static background
  function drawStaticBG(g){
    const sky=g.createLinearGradient(0,0,0,H); sky.addColorStop(0,'#2a0036'); sky.addColorStop(0.35,'#5b006b'); sky.addColorStop(0.62,'#ff2e93'); sky.addColorStop(0.82,'#ffb36b'); sky.addColorStop(1,'#1b0033'); g.fillStyle=sky; g.fillRect(0,0,W,H);
    const sunG=g.createRadialGradient(cx,SUN_Y,8,cx,SUN_Y,SUN_R); sunG.addColorStop(0,'#fff0a8'); sunG.addColorStop(1,'#ff6d6d'); g.fillStyle=sunG; g.beginPath(); g.arc(cx,SUN_Y,SUN_R,0,Math.PI*2); g.fill();
    g.save(); g.beginPath(); g.arc(cx,SUN_Y,SUN_R,0,Math.PI*2); g.clip(); g.globalAlpha=0.35; for(let y=-SUN_R;y<SUN_R;y+=4){ const yy=SUN_Y+y; g.fillStyle=(y%8===0)?'#ff2e93':'#ff9c6b'; g.fillRect(cx-SUN_R,yy,SUN_R*2,2);} g.restore();
    // mountains
    let back=g.createLinearGradient(0,horizonY-60,0,horizonY); back.addColorStop(0,'#0d1630'); back.addColorStop(1,'#0a1a26'); g.fillStyle=back; g.beginPath(); g.moveTo(0,horizonY); for(let x=0;x<=W;x+=8){ const y=horizonY-22-16*Math.sin(x*0.03)-10*Math.sin(x*0.115+1.7); g.lineTo(x,y);} g.lineTo(W,horizonY); g.closePath(); g.fill();
    let front=g.createLinearGradient(0,horizonY-20,0,horizonY+5); front.addColorStop(0,'#0d1f3f'); front.addColorStop(1,'#0b2233'); g.fillStyle=front; g.beginPath(); g.moveTo(0,horizonY+2); for(let x=0;x<=W;x+=10){ const y=horizonY-8-10*Math.sin(x*0.05+0.5)-6*Math.sin(x*0.14+2.1); g.lineTo(x,y);} g.lineTo(W,horizonY+2); g.closePath(); g.fill();
    // road
    const top=roadEdgesAtY(horizonY+1), bot=roadEdgesAtY(H); g.fillStyle='#0f001a'; g.beginPath(); g.moveTo(top.left,horizonY); g.lineTo(top.right,horizonY); g.lineTo(bot.right,H); g.lineTo(bot.left,H); g.closePath(); g.fill();
    g.save(); g.shadowColor='#ff2e93'; g.shadowBlur=8; g.strokeStyle='#ff2e93'; g.lineWidth=2; g.beginPath(); g.moveTo(top.left,horizonY); g.lineTo(bot.left,H); g.stroke(); g.beginPath(); g.moveTo(top.right,horizonY); g.lineTo(bot.right,H); g.stroke(); g.restore();
    g.strokeStyle='#ff2e93'; g.lineWidth=2; g.globalAlpha=0.9; for(let l=1;l<LANES;l++){ g.beginPath(); for(let y=horizonY;y<=H;y+=8){ const e=roadEdgesAtY(y); const xx=e.left+(e.width/LANES)*l; if(y===horizonY) g.moveTo(xx,y); else g.lineTo(xx,y);} g.stroke(); } g.globalAlpha=1;
    g.strokeStyle='#00f5ff'; g.lineWidth=1; g.globalAlpha=0.42; for(let i=0;i<30;i+=2){ const t=i/30; const y=lerp(horizonY,H,t*t); const e=roadEdgesAtY(y); g.beginPath(); g.moveTo(e.left,y); g.lineTo(e.right,y); g.stroke(); } g.globalAlpha=1;
  }
  function buildBG(){
    bg = document.createElement('canvas');
    bg.width = canvas.width; bg.height = canvas.height;
    bgctx = bg.getContext('2d');
    bgctx.setTransform(pxScale,0,0,pxScale,0,0);
    bgctx.imageSmoothingEnabled = true; bgctx.imageSmoothingQuality = 'high';
    drawStaticBG(bgctx);
    if (typeof window.__applyStartBG==='function') window.__applyStartBG();
  }

  // ---- input
  const playerY=H*0.78; const player={ lane:1, width:74, height:108, x(){ return laneXAtY(this.lane,playerY);} };
  window.addEventListener('keydown', e => {
    if (e.code==='Space' || e.key===' ') {
      if (state.started && !state.gameOver) { state.paused = !state.paused; e.preventDefault(); }
      return;
    }
    if (state.paused) return;
    if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') player.lane=Math.max(0,player.lane-1);
    else if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') player.lane=Math.min(LANES-1,player.lane+1);
  });
  window.addEventListener('touchstart',e=>{ const x=e.touches[0].clientX; if(x<window.innerWidth/2) player.lane=Math.max(0,player.lane-1); else player.lane=Math.min(LANES-1,player.lane+1); });

  // ---- spawn
  const obstacles=[]; let nextSpawn=1.0;
  function spawnObstacle(){
    let lane=(Math.random()*LANES)|0; if(lane===lastCatLane) lane=(lane+1)%LANES;
    let tries=0; while(tries<LANES && state.time - (lastHealthSpawn[lane]||-99) < 0.7){ lane=(lane+1)%LANES; tries++; }
    if(tries>=LANES && state.time - (lastHealthSpawn[lane]||-99) < 0.7){ nextSpawn += 0.2; return; }
    obstacles.push({lane,y:horizonY+2,type:'cat',passed:false,flashT:0,mirror:Math.random()<0.5,col:['#ffffff','#ffea70','#ff7a00'][(Math.random()*3)|0]});
    lastCatLane=lane; lastCatSpawn[lane]=state.time; const gap=state.time - lastCatSpawnTime; lastCatSpawnTime=state.time;
    nextSpawn = state.time + ((gap<1.3?1500:1000) + Math.random()*(gap<1.3?500:1000))/1000;
  }
  const palms=[]; function spawnPalm(side){ palms.push({side,y:-Math.random()*H}); } for(let i=0;i<12;i++){ spawnPalm(-1); spawnPalm(1); }

  // ---- draw title & smoke over cached bg
  function drawTitleAndSmoke(sunY,sunR){ const txt=titleText; const fs=Math.min(44, Math.max(22, Math.floor(W*0.085))); ctx.save(); ctx.font='900 '+fs+'px monospace'; ctx.textAlign='center'; ctx.textBaseline='alphabetic'; const titleY=(sunY-sunR)-6; const m=ctx.measureText(txt); const ascent=m.actualBoundingBoxAscent||fs*0.72; const descent=m.actualBoundingBoxDescent||fs*0.28; const top=titleY-ascent; titleBox={ left:cx-m.width/2, top, width:m.width, height:ascent+descent}; ctx.shadowColor='#ff2e93'; ctx.shadowBlur=12; ctx.lineWidth=3; ctx.strokeStyle='#ff2e93'; ctx.strokeText(txt,cx,titleY); ctx.shadowBlur=0; ctx.lineWidth=1; ctx.strokeStyle='#00f5ff88'; ctx.strokeText(txt,cx,titleY); let g = gradCache['title:'+Math.round(titleBox.height)]; if(!g){ g=ctx.createLinearGradient(0,top,0,top+titleBox.height); g.addColorStop(0,'#fff4cf'); g.addColorStop(1,'#ff6db3'); gradCache['title:'+Math.round(titleBox.height)] = g; } ctx.fillStyle=g; ctx.fillText(txt,cx,titleY); drawSmoke(); ctx.restore(); }

  // ---- car (XC90-ish rear)
  function drawPlayer(){ const x=player.x(), y=playerY, brakeOn=(state.time<state.stopUntil), w=player.width, h=player.height; ctx.save(); ctx.translate(x,y);
    ctx.globalAlpha=0.32; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(0,h*0.60,w*0.62,8,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    let shell=ctx.createLinearGradient(0,-h*0.55,0,h*0.40); shell.addColorStop(0,'#ffffff'); shell.addColorStop(1,'#cfd6e0'); ctx.fillStyle=shell; ctx.beginPath(); ctx.moveTo(-w*0.62,h*0.36); ctx.lineTo(w*0.62,h*0.36); ctx.lineTo(w*0.66,h*0.08); ctx.lineTo(w*0.54,-h*0.06); ctx.lineTo(w*0.48,-h*0.18); ctx.lineTo(-w*0.48,-h*0.18); ctx.lineTo(-w*0.54,-h*0.06); ctx.lineTo(-w*0.66,h*0.08); ctx.closePath(); ctx.fill(); ctx.strokeStyle='#4a5260'; ctx.lineWidth=1.5; ctx.stroke();
    let glass=ctx.createLinearGradient(0,-h*0.22,0,h*0.05); glass.addColorStop(0,'#0b1220'); glass.addColorStop(1,'#1c2a3a'); ctx.fillStyle=glass; const rw=w*0.82, rh=h*0.36; ctx.fillRect(-rw/2,-h*0.20,rw,rh);
    if(brakeOn){ const hbW=w*0.26, hbH=Math.max(3,h*0.02), hbY=-h*0.20+1; const hbGrad=ctx.createLinearGradient(0,hbY-hbH,0,hbY+hbH); hbGrad.addColorStop(0,'#ffd4da'); hbGrad.addColorStop(1,'#ff0033'); ctx.save(); ctx.shadowColor='#ff1a2f'; ctx.shadowBlur=12; ctx.fillStyle=hbGrad; ctx.fillRect(-hbW/2,hbY,hbW,hbH); ctx.restore(); }
    ctx.strokeStyle='#aab6c6'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-w*0.05,-h*0.02); ctx.lineTo(w*0.20,-h*0.08); ctx.stroke();
    let trim=ctx.createLinearGradient(0,0,0,h*0.07); trim.addColorStop(0,'#e7eef8'); trim.addColorStop(1,'#a8bccf'); ctx.fillStyle=trim; ctx.fillRect(-w*0.46,h*0.02,w*0.92,h*0.06);
    ctx.fillStyle='#6b7d91'; ctx.font='bold 9px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('VOLVO',0,h*0.05);
    function drawVolvoTailLight(side){ const sgn=side<0?-1:1; const xOuterBot=side<0?-w*0.62:w*0.62; const xOuterTop=xOuterBot-sgn*(w*0.065); const xInnerBot=xOuterBot-sgn*(w*0.125); const xInnerTop=xOuterTop-sgn*(w*0.055); const xHook=xOuterTop-sgn*(w*0.10); const yBot=h*0.30,yMid=-h*0.02,yHook=-h*0.14,yTop=-h*0.18; const pts=[]; for(let i=0;i<=13;i++){ const t=i/13; pts.push([ xOuterBot+(xOuterTop-xOuterBot)*t, yBot+(yTop-yBot)*t ]);} for(let i=1;i<=8;i++){ const t=i/8; pts.push([ xOuterTop+(xHook-xOuterTop)*t, yTop+(yHook-yTop)*t ]);} for(let i=1;i<=6;i++){ const t=i/6; pts.push([ xInnerTop, yHook+(yMid-yHook)*t ]);} for(let i=1;i<=8;i++){ const t=i/8; pts.push([ xInnerTop+(xInnerBot-xInnerTop)*t, yMid+(yBot-yMid)*t ]);} const grad=ctx.createLinearGradient(0,yTop,0,yBot); grad.addColorStop(0,brakeOn?'#ffccd5':'#ff9aab'); grad.addColorStop(0.5,brakeOn?'#ff2a3e':'#ff2340'); grad.addColorStop(1,brakeOn?'#8e0018':'#660010'); ctx.save(); ctx.beginPath(); ctx.moveTo(pts[0][0],pts[0][1]); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]); ctx.closePath(); ctx.fillStyle=grad; ctx.fill(); ctx.save(); ctx.beginPath(); ctx.moveTo(pts[0][0],pts[0][1]); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]); ctx.closePath(); ctx.clip(); const bandY=-h*0.02, bandH=h*0.07; ctx.fillStyle='#ffbf3b'; const bandLeft=Math.min(xOuterTop,xInnerTop); const bandW=Math.abs(xOuterTop-xInnerTop); ctx.fillRect(bandLeft,bandY,bandW,bandH); ctx.restore(); ctx.lineWidth=1.1; ctx.strokeStyle='#4e0010'; ctx.stroke(); ctx.restore(); }
    function clipBodyInterior(){ ctx.beginPath(); ctx.moveTo(-w*0.60,h*0.34); ctx.lineTo(w*0.60,h*0.34); ctx.lineTo(w*0.64,h*0.08); ctx.lineTo(w*0.52,-h*0.06); ctx.lineTo(w*0.46,-h*0.18); ctx.lineTo(-w*0.46,-h*0.18); ctx.lineTo(-w*0.52,-h*0.06); ctx.lineTo(-w*0.64,h*0.08); ctx.closePath(); ctx.clip(); }
    ctx.save(); clipBodyInterior(); drawVolvoTailLight(-1); drawVolvoTailLight(1); ctx.restore();
    ctx.fillStyle='#eef6ff'; ctx.fillRect(-w*0.18,h*0.16,w*0.14,h*0.06); ctx.fillRect(w*0.04,h*0.16,w*0.14,h*0.06);
    let plate=ctx.createLinearGradient(0,h*0.10,0,h*0.22); plate.addColorStop(0,'#f7fbff'); plate.addColorStop(1,'#bcc8d6'); ctx.fillStyle=plate; const plateY=h*0.08, plateH=h*0.10, plateW=w*0.44; ctx.fillRect(-plateW/2,plateY,plateW,plateH); ctx.fillStyle='#111'; ctx.font='bold '+Math.max(10,Math.floor(plateH*0.65))+'px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('420',0,plateY+plateH/2);
    ctx.fillStyle='#1c2734'; ctx.fillRect(-w*0.62,h*0.26,w*1.24,h*0.12);
    let skid=ctx.createLinearGradient(0,h*0.30,0,h*0.42); skid.addColorStop(0,'#d7dde6'); skid.addColorStop(1,'#7a8796'); ctx.fillStyle=skid; ctx.fillRect(-w*0.52,h*0.32,w*1.04,h*0.10);
    ctx.fillStyle='#3a424c'; ctx.beginPath(); ctx.ellipse(-w*0.28,h*0.40,5,3.4,0,0,Math.PI*2); ctx.fill();
    let ug=ctx.createRadialGradient(0,h*0.52,2,0,h*0.52,w*0.80); ug.addColorStop(0,'rgba(0,245,255,0.18)'); ug.addColorStop(1,'rgba(0,245,255,0)'); ctx.fillStyle=ug; ctx.beginPath(); ctx.ellipse(0,h*0.52,w*0.86,12,0,0,Math.PI*2); ctx.fill();
    ctx.restore(); }

  // ---- cat sprite
  function drawCatSprite(c='#39ff14'){ const w=28,h=18*1.3; const legW=Math.max(2,w*0.10), legH=h*0.26; function leg(x,y){ ctx.save(); ctx.shadowColor=c; ctx.shadowBlur=6; ctx.fillStyle=c; ctx.globalAlpha=0.95; ctx.fillRect(x-legW/2,y,legW,legH); ctx.beginPath(); ctx.ellipse(x,y+legH+2.2,Math.max(1.6,legW*0.9),2.2,0,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; ctx.globalAlpha=1; ctx.strokeStyle=c; ctx.lineWidth=2; ctx.strokeRect(x-legW/2,y,legW,legH); ctx.beginPath(); ctx.ellipse(x,y+legH+2.2,Math.max(1.6,legW*0.9),2.2,0,0,Math.PI*2); ctx.stroke(); ctx.restore(); } leg(-w*0.22,h*0.12); leg(w*0.24,h*0.12); leg(-w*0.35,h*0.08); leg(w*0.06,h*0.08);
    ctx.globalAlpha=0.28; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(0,h*0.42,w*0.55,3.5,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.fillStyle='#0c0f1e'; ctx.beginPath(); ctx.ellipse(0,0,w*0.58,h*0.36,0,0,Math.PI*2); ctx.fill();
    const hx=-w*0.52, hy=-h*0.10, hr=h*0.38;
    // carve body behind head so head reads on top
    ctx.save(); ctx.globalCompositeOperation='destination-out'; ctx.beginPath(); ctx.arc(hx,hy,hr,0,Math.PI*2); ctx.fill(); ctx.restore();
    // head on top
    ctx.fillStyle='#0c0f1e'; ctx.beginPath(); ctx.arc(hx,hy,hr,0,Math.PI*2); ctx.fill();
    // ears
    ctx.fillStyle='#0c0f1e'; ctx.strokeStyle=c; ctx.lineWidth=2; const baseY=hy-hr*0.85; const half=hr*0.36; const height=Math.sqrt(3)*half; const cxL=hx-hr*0.42, cxR=hx+hr*0.20; function ear(cx,sign){ const th=sign*0.22, ct=Math.cos(th), st=Math.sin(th); const p1={x:cx-half,y:baseY}, p2={x:cx+half,y:baseY}, p3={x:cx,y:baseY-height}; function rot(p){ const dx=p.x-cx, dy=p.y-baseY; return {x:cx+dx*ct-dy*st, y:baseY+dx*st+dy*ct}; } const r1=rot(p1), r2=rot(p2), r3=rot(p3); ctx.beginPath(); ctx.moveTo(r1.x,r1.y); ctx.lineTo(r2.x,r2.y); ctx.lineTo(r3.x,r3.y); ctx.closePath(); ctx.fill(); ctx.stroke(); } ear(cxL,-1); ear(cxR,1);
    const wag=Math.sin(state.time*2)*h*0.04; ctx.strokeStyle=c; ctx.lineWidth=2; ctx.globalAlpha=0.9; ctx.beginPath(); ctx.moveTo(w*0.55,-h*0.05); ctx.quadraticCurveTo(w*0.86,-h*0.38+wag,w*0.48,-h*0.56+wag); ctx.quadraticCurveTo(w*0.28,-h*0.70+wag,w*0.40,-h*0.24+wag*0.6); ctx.stroke(); ctx.globalAlpha=1;
    const eyeOffset=hr*0.36, eyeY=hy+hr*0.02; for(const ex of [hx-eyeOffset, hx+eyeOffset*0.25]){ const g=ctx.createRadialGradient(ex,eyeY,0.1,ex,eyeY,3); g.addColorStop(0,'rgba(170,255,68,0.9)'); g.addColorStop(1,'rgba(170,255,68,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(ex,eyeY,3,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#caff59'; ctx.beginPath(); ctx.ellipse(ex,eyeY,2.2,1.5,0,0,Math.PI*2); ctx.fill(); }
    ctx.strokeStyle='#b7dfff'; ctx.lineWidth=1; for(let i=-1;i<=1;i++){ const yy=hy+i*3; ctx.beginPath(); ctx.moveTo(hx-2,yy); ctx.lineTo(hx-20,yy-1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(hx+2,yy); ctx.lineTo(hx+18,yy-1); ctx.stroke(); }
    ctx.strokeStyle=c; ctx.lineWidth=2; ctx.globalAlpha=0.9; ctx.save(); ctx.beginPath(); ctx.rect(-1000,-1000,2000,2000); ctx.arc(hx,hy,hr,0,Math.PI*2,true); ctx.clip(); ctx.beginPath(); ctx.ellipse(0,0,w*0.58,h*0.36,0,0,Math.PI*2); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.arc(hx,hy,hr,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }

  // ---- obstacles
  function drawObstacle(o){ if(o.flying){ ctx.save(); ctx.translate(o.fx??0,o.fy??0); if(o.rot) ctx.rotate(o.rot); const s=o.fs??1, mx=o.mirror?-1:1; ctx.scale(s*mx,s); drawCatSprite(o.col); ctx.restore(); return;} const y=o.y, x=laneXAtY(o.lane,y); ctx.save(); ctx.translate(x,y); const t=clamp((y-horizonY)/(H-horizonY),0,1); const s=clamp(lerp(0.25,1.1,t),0.25,1.1), mx=o.mirror?-1:1; ctx.scale(s*mx,s); drawCatSprite(o.col); ctx.restore(); }
  function collide(o){ if(o.lane!==player.lane) return false; const gateFactor = (o.type==='cat') ? 0.85 : 0.80; const gateY = horizonY + gateFactor*(playerY - horizonY); if(o.y<gateY) return false; const hitZone=28; return Math.abs(o.y-playerY)<hitZone; }
  function resetGame(){ state.distance=0; state.hits=0; state.lives=4; state.gameOver=false; state.stopUntil=0; obstacles.length=0; nextSpawn=state.time+1.2; state.health=1; healths.length=0; nextHeal=state.time+2.0; htrail.length=0; state.deathReason=null; }
  function addHighScore(d){ const v=Math.max(0,Math.floor(d)); state.highScores.push(v); state.highScores.sort((a,b)=>b-a); if(state.highScores.length>3) state.highScores.length=3; }

  // ---- HUDs
  function drawCanvasHUD(){
    const dist=Math.floor(state.distance), heartsTotal=4, heartsLeft=clamp(state.lives,0,heartsTotal);
    ctx.save(); ctx.font='bold 14px monospace'; ctx.textAlign='left'; ctx.textBaseline='top';
    const padding=6, lineH=18, boxW=Math.floor(180*0.7), boxH=lineH*3+padding*2, x=W-boxW-8;
    let y=8; if(titleBox) y=Math.max(y, Math.round(titleBox.top+titleBox.height+12)); y=clamp(y,8,H-boxH-8);
    function heart(hx_,hy_,s,filled){ ctx.save(); if(filled){ ctx.shadowColor='#ff2e93'; ctx.shadowBlur=6; }
      ctx.beginPath(); ctx.moveTo(hx_,hy_+s*0.6*1.2); ctx.bezierCurveTo(hx_-s*1.2,hy_+s*0.2*1.2,hx_-s*1.2,hy_-s*0.6*1.2,hx_,hy_-s*0.1*1.2); ctx.bezierCurveTo(hx_+s*1.2,hy_-s*0.6*1.2,hx_+s*1.2,hy_+s*0.2*1.2,hx_,hy_+s*0.6*1.2);
      if(filled){ const gr=ctx.createLinearGradient(0,hy_-s*1.2,0,hy_+s*1.2); gr.addColorStop(0,'#ff9ac5'); gr.addColorStop(1,'#ff2e93'); ctx.fillStyle=gr; ctx.fill(); }
      ctx.shadowBlur=0; ctx.lineWidth=1.5; ctx.strokeStyle=filled?'#ff2e93':'#ff2e93aa'; ctx.stroke(); ctx.restore(); }
    panel(x,y,boxW,boxH,(px,py,pw,ph)=>{
      const tx=px+padding, ty=py+padding; ctx.fillStyle='#ffffff';
      ctx.fillText('Distance: '+dist,tx,ty); ctx.fillText('Life:',tx,ty+lineH);
      const heartSize=7.5; let hx=tx+44, hy=ty+lineH+4; for(let i=0;i<heartsTotal;i++) heart(hx+i*(heartSize*2.2),hy,heartSize,i<heartsLeft);
      ctx.fillText('Lean:', tx, ty + lineH*2);
      const innerW = boxW - padding*2; const barW = Math.floor(innerW * 0.55); const barH = 6; const barY = ty + lineH*2 + 4; const barX = tx + innerW - barW;
      ctx.fillStyle='#00000066'; ctx.fillRect(barX,barY,barW,barH);
      ctx.save(); ctx.shadowColor='#39ff14'; ctx.shadowBlur=8; ctx.fillStyle='#39ff14'; ctx.fillRect(barX,barY, barW*clamp(state.health,0,1), barH); ctx.restore();
    });
    ctx.restore();
  }
  function drawHighScoresHUD(){
    ctx.save(); ctx.font='bold 14px monospace'; ctx.textAlign='left'; ctx.textBaseline='top';
    const padding=6, lineH=18, x=8;
    const headerW = ctx.measureText('High Scores').width;
    const boxH = lineH*4 + padding*2;
    const boxW = Math.ceil(headerW + padding*2 + 8);
    let y=8; if(titleBox) y=Math.max(y, Math.round(titleBox.top+titleBox.height+12)); y=clamp(y,8,H-boxH-8);
    panel(x,y,boxW,boxH,(px,py)=>{
      const tx=px+padding, ty=py+padding; ctx.fillStyle='#ffffff';
      ctx.fillText('High Scores',tx,ty);
      for(let i=0;i<3;i++){ const v=state.highScores[i]; const txt=(typeof v==='number')?String(v):'-----';
        ctx.fillText(`${i+1}. ${txt}`, tx, ty+(i+1)*lineH); }
    });
    ctx.restore();
  }

  // ---- palms
  function drawPalm(y,side){ if(y<horizonY-6||y>H+60) return; const e=roadEdgesAtY(y); const baseX=side<0?e.left-14:e.right+14; const t=clamp((y-horizonY)/(H-horizonY),0,1); const s=clamp(lerp(0.22,1.45,t),0.22,1.45); const trunkH=46*s, trunkW=6; const topX=baseX+(side<0?-6*s:6*s), topY=y-trunkH; ctx.fillStyle='#7a4a1a'; ctx.beginPath(); ctx.moveTo(baseX-trunkW/2,y); ctx.lineTo(baseX+trunkW/2,y); ctx.lineTo(topX+trunkW*0.35,topY); ctx.lineTo(topX-trunkW*0.35,topY); ctx.closePath(); ctx.fill(); const crownX=topX, crownY=topY; ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#39ff14'; ctx.lineWidth=Math.max(1.6,2.0*s); const axisOut=(side<0?Math.PI:0)+(side<0?-0.12:0.12), axisIn=axisOut+Math.PI; const bankOut=[-0.80,-0.42,0.36], bankIn=[-0.70,-0.18,0.58]; const len0=30*s; function leaf(axis,off,idx){ const a=axis+off, L=len0*(0.92+0.15*Math.sin(idx*1.7)), spread=0.18*(1-Math.min(1,Math.abs(off)/1.1)), droop=(0.12+0.22*Math.max(0,off))*L; const tipX=crownX+Math.cos(a)*L, tipY=crownY+Math.sin(a)*L+droop; for(const k of [-1,1]){ const ae=a+k*spread, perp=ae+Math.PI/2; const c1x=crownX+Math.cos(ae)*L*0.45+Math.cos(perp)*L*0.12, c1y=crownY+Math.sin(ae)*L*0.45+Math.sin(perp)*L*0.12; const c2x=crownX+Math.cos(ae)*L*0.82-Math.cos(perp)*L*0.15, c2y=crownY+Math.sin(ae)*L*0.82-Math.sin(perp)*L*0.08+droop*0.6; ctx.beginPath(); ctx.moveTo(crownX,crownY); ctx.bezierCurveTo(c1x,c1y,c2x,c2y,tipX,tipY); ctx.stroke(); } }
    let idx=0; for(const o of bankOut) leaf(axisOut,o,idx++); for(const o of bankIn) leaf(axisIn,o,idx++); ctx.restore(); }

  // ---- health trail (fixed)
  const htrail=[];
  function spawnHealthTrailFrom(h){ const y=h.y, xc=laneXAtY(h.lane,y), t=clamp((y-horizonY)/(H-horizonY),0,1), s=clamp(lerp(0.25,1.1,t),0.25,1.1), mx=h.mirror?-1:1, half=24*1.2/2; htrail.push({x:xc+s*mx*half,y, vx:(Math.random()-0.5)*20,vy:-(20+Math.random()*30),r:2+Math.random()*2,life:0,max:0.5+Math.random()*0.3}); }
  function updateHealthTrail(dt){ for(let i=htrail.length-1;i>=0;i--){ const p=htrail[i]; p.life+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.98; p.vy*=0.98; if(p.life>p.max) htrail.splice(i,1); } }
  function drawHealthTrail(){ if(!htrail.length) return; ctx.save(); ctx.globalCompositeOperation='lighter'; for(const p of htrail){ const t=p.life/p.max, a=(1-t)*0.35, rad=p.r*(1+t*1.2); const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,rad); g.addColorStop(0,`rgba(170,120,120,${a})`); g.addColorStop(1,'rgba(170,120,120,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill(); } ctx.restore(); }

  // ---- car smoke plume (on health pickup)
  const carSmoke=[]; let carSmokeEmitUntil=0; let carSmokeAcc=0;
  function spawnCarSmoke(){ const x=player.x()-player.width*0.52; const y=playerY-player.height*0.12; carSmoke.push({x,y,vx:-(40+Math.random()*60),vy:-(10+Math.random()*30),r:2+Math.random()*2,life:0,max:1.0}); }
  function updateCarSmoke(dt){ if(state.time < carSmokeEmitUntil){ carSmokeAcc += dt*40; while(carSmokeAcc>=1){ spawnCarSmoke(); carSmokeAcc-=1; } } for(let i=carSmoke.length-1;i>=0;i--){ const p=carSmoke[i]; p.life+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.98; p.vy-=20*dt; p.r+=14*dt; if(p.life>p.max) carSmoke.splice(i,1);} }
  function drawCarSmoke(){ if(!carSmoke.length) return; ctx.save(); ctx.globalCompositeOperation='lighter'; for(const p of carSmoke){ const t=p.life/p.max, a=(1-t)*0.4, r=Math.max(1,p.r); const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r); g.addColorStop(0,`rgba(220,220,220,${a})`); g.addColorStop(1,'rgba(220,220,220,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); }

  // ---- update
  function update(dt){ state.time+=dt; if(state.time<state.stopUntil){ if(nextSpawn<state.stopUntil) nextSpawn=state.stopUntil; if(nextHeal<state.stopUntil) nextHeal=state.stopUntil; } updateSmoke(dt); updatePoofs(dt); updateHealthTrail(dt); updateCarSmoke(dt);
    state.health=clamp((state.health??1)-dt/10,0,1); if(state.health<=0 && !state.gameOver){ state.deathReason='health'; addHighScore(state.distance); state.gameOver=true; state.restartAt = state.time+4.0; state.stopUntil=0; }
    if(!state.gameOver && state.time>=nextHeal) spawnHealth(); if(!state.gameOver && state.time>=nextSpawn) spawnObstacle(); const moving=(state.gameOver||state.time<state.stopUntil)?0:state.normalSpeed*SPEED_SCALE; palms.forEach(p=>{ p.y+=moving*dt*0.8; if(p.y>H+64) p.y=-Math.random()*H; }); obstacles.forEach(o=>{ if(o.flying){ o.vy=(o.vy??0)+(o.gravity??220)*dt; o.fx+=(o.vx??0)*dt; o.fy+=(o.vy??0)*dt; if(o.rvel) o.rot=(o.rot||0)+o.rvel*dt; if(o.fs) o.fs*=0.995; } else { o.y = forwardStep(o.y, dt, moving); } }); healths.forEach(h=>{ h.y = forwardStep(h.y, dt, moving); h.smokeAcc=(h.smokeAcc||0)+dt*18; while(h.smokeAcc>=1){ spawnHealthTrailFrom(h); h.smokeAcc-=1; } }); for(let i=healths.length-1;i>=0;i--){ const h=healths[i]; if(collide(h)){ state.health=clamp(state.health+HEALTH_REPLENISH,0,1); carSmokeEmitUntil = state.time + 1.0; healths.splice(i,1);} }
    state.distance+=moving*dt/10; if(moving>0){ for(const o of obstacles){ if(!o.passed && collide(o)){ o.passed=true; state.hits++; if(state.lives>0) state.lives--; try{ const a=document.getElementById('sfx_meow'); if(a){ a.currentTime=0; a.play().catch(()=>{}); } }catch(e){} if(state.lives<=0 && !state.gameOver){ const yHit=o.y, xHit=laneXAtY(o.lane,yHit); const tScale=clamp((yHit-horizonY)/(H-horizonY),0,1); const sScale=clamp(lerp(0.25,1.1,tScale),0.25,1.1); o.flying=true; o.fx=xHit; o.fy=yHit; o.fs=sScale; o.rot=0; o.vx=(Math.random()<0.5?-1:1)*(160+Math.random()*140); o.vy=-(140+Math.random()*180); o.rvel=(Math.random()*2-1)*6; o.gravity=300; spawnPoof(xHit,yHit,sScale); state.deathReason='life'; addHighScore(state.distance); state.gameOver=true; state.restartAt = state.time+4.0; state.stopUntil=0; } else { const yHit=o.y, xHit=laneXAtY(o.lane,yHit); const tScale=clamp((yHit-horizonY)/(H-horizonY),0,1); const sScale=clamp(lerp(0.25,1.1,tScale),0.25,1.1); o.flying=true; o.fx=xHit; o.fy=yHit; o.fs=sScale; o.rot=0; o.vx=(Math.random()<0.5?-1:1)*(140+Math.random()*120); o.vy=-(120+Math.random()*160); o.rvel=(Math.random()*2-1)*6; o.gravity=300; spawnPoof(xHit,yHit,sScale); state.stopUntil=state.time+2.0; } break; } } }
    pruneOffscreen(obstacles); pruneOffscreen(healths);
    if(state.gameOver && state.time>=state.restartAt) resetGame(); }

  // ---- draw
  function draw(){ if(bg){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.drawImage(bg,0,0); ctx.restore(); drawTitleAndSmoke(SUN_Y,SUN_R); } else { const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#2a0036'); g.addColorStop(1,'#1b0033'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); drawTitleAndSmoke(SUN_Y,SUN_R); }
    const moving=(state.gameOver||state.time<state.stopUntil)?0:state.normalSpeed*SPEED_SCALE; const bob = moving ? Math.sin(state.time*2.2)*1.5 : 0; ctx.save(); ctx.translate(0, bob);
    palms.forEach(p=>drawPalm(p.y,p.side)); obstacles.forEach(drawObstacle); healths.forEach(drawHealthItem); drawPlayer(); drawCarSmoke(); drawPoofs(); drawHealthTrail(); ctx.restore();
    drawCanvasHUD(); drawHighScoresHUD();
    if(state.paused){ ctx.save(); const msg='PAUSE'; ctx.textAlign='center'; ctx.textBaseline='middle'; let fs = fitSize(msg, Math.floor(H/3.2), W*0.9); ctx.font='900 '+fs+'px monospace'; drawLabel(msg, cx, H*0.5, { lw: Math.max(3, Math.floor(fs*0.06)), stroke:'#000', fill:'#ffffff', vhs:true }); ctx.restore(); return; }
    if(state.gameOver){ ctx.save(); const msg='GAME OVER'; ctx.textAlign='center'; ctx.textBaseline='middle'; let fs = fitSize(msg, Math.floor(H/3), W*0.92); ctx.font='900 '+fs+'px monospace'; const blink=(Math.sin(state.time*5)>0)?1.0:0.75; ctx.globalAlpha=blink; const grad=ctx.createLinearGradient(0,(H/2)-fs*0.6,0,(H/2)+fs*0.6); grad.addColorStop(0,'#ffd1d6'); grad.addColorStop(0.35,'#ff3350'); grad.addColorStop(1,'#a40014'); drawLabel(msg, cx, H*0.5, { fill:grad, stroke:'#51000c', lw: Math.max(3, Math.floor(fs*0.065)), shadow:{color:'#ff0022', blur:Math.max(12,Math.floor(fs*0.2))} }); ctx.globalAlpha=1; const sub=(state.deathReason==='health')?'You became sober':'You killed too many Shmmees'; const fs2=Math.max(12,Math.floor(fs*0.18)); ctx.font='bold '+fs2+'px monospace'; drawLabel(sub, cx, H*0.5 + fs*0.50, { fill:'#ffffff', stroke:'#000', lw: Math.max(2, Math.floor(fs*0.035)) }); ctx.restore(); }
    else if(state.time<state.stopUntil){ ctx.save(); const msg="Don't hit the Shmee!"; ctx.textAlign='center'; ctx.textBaseline='middle'; let fs = fitSize(msg, 64, W*0.95); ctx.font='900 '+fs+'px monospace'; const y=Math.min(H-fs,H*0.60); const grad=ctx.createLinearGradient(0,y-fs*0.6,0,y+fs*0.6); grad.addColorStop(0,'#ffe5ff'); grad.addColorStop(0.4,'#ff2e93'); grad.addColorStop(1,'#ff0033'); drawLabel(msg, cx, y, { fill:grad, stroke:'#220011', lw: Math.max(3, Math.floor(fs*0.06)), shadow:{color:'#ff0033', blur:Math.max(12, Math.floor(fs*0.25))} }); ctx.restore(); }
  }

  // ---- loop
  let last=0; function loop(t){ const now=t/1000, dt=Math.min(0.033,(last?now-last:0)); last=now; if(!state.started){ ctx.clearRect(0,0,W,H); if(bg){ ctx.drawImage(bg,0,0); drawTitleAndSmoke(SUN_Y,SUN_R); } else { const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#2a0036'); g.addColorStop(1,'#1b0033'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); drawTitleAndSmoke(SUN_Y,SUN_R); } requestAnimationFrame(loop); return; } if(!state.paused) update(dt); ctx.clearRect(0,0,W,H); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

  // ---- fit + build bg
  function fit(){
    const ww=window.innerWidth, wh=window.innerHeight; const dpr = window.devicePixelRatio || 1; const s=Math.min(ww/W, wh/H); pxScale = dpr * s;
    canvas.style.width=Math.floor(W*s)+'px'; canvas.style.height=Math.floor(H*s)+'px'; canvas.width = Math.floor(W*pxScale); canvas.height = Math.floor(H*pxScale);
    ctx.setTransform(pxScale,0,0,pxScale,0,0); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high'; clearGradients(); buildBG();
  }
  window.addEventListener('resize',fit); fit();

  // ---- start overlay
  const startBtn=document.getElementById('startBtn'), startOv=document.getElementById('startOverlay');
  // use cached bg canvas for start overlay backdrop (no redraw)
  window.__applyStartBG = function(){ if(!startOv) return; if(bg){ try{ const url=bg.toDataURL('image/png'); startOv.style.backgroundImage='url('+url+')'; startOv.style.backgroundSize='cover'; startOv.style.backgroundPosition='center'; startOv.style.backgroundRepeat='no-repeat'; }catch(e){} } };
  window.__applyStartBG();
  if(startBtn&&startOv){ startBtn.addEventListener('click',()=>{
    const el=document.documentElement; const req=el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen; 
    const allowed=!!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.msFullscreenEnabled);
    const isMobile=(/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) || (window.matchMedia && matchMedia('(pointer:coarse)').matches && Math.max(screen.width,screen.height)<1200);
    if(isMobile && req && allowed){ try { const p=req.call(el); if(p && typeof p.catch==='function') p.catch(()=>{}); } catch (e) { /* ignore */ } }
    state.started=true; startOv.style.display='none';
  }); }

  // ---- background music controls (restored)
  (function(){
    function init(){
      const bgm=document.getElementById('bgm');
      const bp=document.getElementById('btnPlay');
      const bm=document.getElementById('btnMute');
      const startBtn=document.getElementById('startBtn');
      // Music wiring (safe even if some elements are missing)
      if(bgm){
        bgm.volume=0.45;
        const savedMute=localStorage.getItem('lean_mute');
        if(savedMute!==null) bgm.muted = savedMute==='1';
        function sync(){ try{ if(bp) bp.textContent=bgm.paused?'▶':'⏸'; if(bm) bm.textContent=bgm.muted?'🔈':'🔇'; }catch(e){} }
        if(startBtn){ startBtn.addEventListener('click',()=>{ bgm.play().then(sync).catch(()=>{}); }); }
        if(bp){ bp.addEventListener('click',()=>{ if(bgm.paused) bgm.play().catch(()=>{}); else bgm.pause(); sync(); }); }
        if(bm){ bm.addEventListener('click',()=>{ bgm.muted=!bgm.muted; localStorage.setItem('lean_mute', bgm.muted?'1':'0'); sync(); }); }
        document.addEventListener('visibilitychange',()=>{ if(document.visibilityState==='visible' && !bgm.paused) bgm.play().catch(()=>{}); });
        sync();
      }

      // Cat SFX mute button
      const sfx=document.getElementById('sfx_meow');
      const bs=document.getElementById('btnSfx');
      function syncSfx(){ try{ if(bs && sfx) bs.textContent = sfx.muted ? '🙀' : '🐱'; }catch(e){} }
      if(sfx){
        sfx.volume = 0.6; // 60% of previous loudness
        const savedSfx=localStorage.getItem('lean_sfx_mute');
        if(savedSfx!==null) sfx.muted = savedSfx==='1';
        if(bs){ bs.addEventListener('click',()=>{ sfx.muted=!sfx.muted; localStorage.setItem('lean_sfx_mute', sfx.muted?'1':'0'); syncSfx(); }); }
        syncSfx();
      }
    }
    if(document.readyState==='loading') window.addEventListener('DOMContentLoaded', init); else init();
  })();

  // ---- health items
  function spawnHealth(){
    // pick a lane not within 0.7s of a cat spawn in same lane
    let lane=(Math.random()*LANES)|0, tries=0;
    while(tries<LANES && state.time - (lastCatSpawn[lane]||-99) < 0.7){ lane=(lane+1)%LANES; tries++; }
    if(tries>=LANES && state.time - (lastCatSpawn[lane]||-99) < 0.7){ nextHeal+=0.2; return; }
    healths.push({lane,y:horizonY+2, mirror:Math.random()<0.5}); lastHealthSpawn[lane]=state.time;
    nextHeal=state.time + (3000+Math.random()*1000)/1000; // 3–4s
  }
  function drawHealthItem(h){
    const y=h.y, x=laneXAtY(h.lane,y);
    ctx.save(); ctx.translate(x,y);
    const t=clamp((h.y-horizonY)/(H-horizonY),0,1); const s=clamp(lerp(0.25,1.1,t),0.25,1.1);
    const mx=h.mirror?-1:1; ctx.scale(s*mx,s);
    const L=24*1.2,half=L/2,tip=L*0.15,tStart=4,tEnd=8,hs0=tStart/2,hs1=tEnd/2;
    // body (slight cone)
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(-half, -hs0); ctx.lineTo(-half,  hs0); ctx.lineTo( half,  hs1); ctx.lineTo( half, -hs1); ctx.closePath(); ctx.fill();
    // red hot tip (~15%)
    const xTip=half-tip,progress=(xTip+half)/L,hsTip=hs0+(hs1-hs0)*progress;
    ctx.save(); ctx.shadowColor = '#ff0022'; ctx.shadowBlur = 10; ctx.fillStyle = '#ff0022'; ctx.beginPath(); ctx.moveTo(xTip, -hsTip); ctx.lineTo(xTip,  hsTip); ctx.lineTo( half,  hs1); ctx.lineTo( half, -hs1); ctx.closePath(); ctx.fill(); ctx.restore();
    ctx.restore();
  }

  // ---- tiny sanity checks (non-invasive)
  try {
    console.assert(typeof spawnObstacle==='function','spawnObstacle exists');
    console.assert(typeof spawnHealth==='function','spawnHealth exists');
    console.assert(typeof draw==='function','draw exists');
  } catch (e) {}

})();
</script>
  <style>
#musicControls{position:fixed;top:8px;left:8px;z-index:3;display:flex;gap:6px}
#musicControls button{font:700 12px/1 monospace;color:#fff;background:#0008;border:1px solid #00f5ff88;border-radius:6px;padding:6px 8px}
#musicControls button:active{transform:translateY(1px)}
#startOverlay{position:fixed;inset:0;display:grid;place-items:center;z-index:5;background-position:center;background-size:cover;background-repeat:no-repeat}
#startBtn{font:900 clamp(16px,4vmin,28px)/1 monospace;color:#fff;background:hsla(136,70%,43%,0.82);border:2px solid #39ff14;border-radius:16px;padding:clamp(12px,3vmin,20px) clamp(24px,8vmin,48px);width:33vmin;height:18vmin;box-shadow:0 0 24px #39ff1444,0 0 8px #39ff14 inset;text-transform:uppercase;letter-spacing:1px}
#startBtn:hover{filter:brightness(1.05)}
#startBtn:active{transform:translateY(1px)}
#startTip{position:fixed;left:50%;transform:translateX(-50%);top:65vh;font:700 clamp(25px,4.6vmin,34px)/1 monospace;color:#fff;text-shadow:0 0 10px #ffea70,0 0 20px #ffea70;white-space:nowrap}
#startTip2{position:fixed;left:50%;transform:translateX(-50%);top:calc(65vh + 6vmin);font:700 clamp(25px,4.6vmin,34px)/1 monospace;color:#fff;text-shadow:0 0 10px #ffea70,0 0 20px #ffea70;white-space:nowrap}
</style>

<div id="musicControls">
  <button id="btnPlay">▶</button>
  <button id="btnMute">🔇</button>
  <button id="btnSfx" title="Toggle cat meow">🐱</button>
</div>
<audio id="bgm" preload="auto" loop src="music.mp3" crossorigin="anonymous"></audio>
<audio id="sfx_meow" preload="auto" src="meow.mp3" crossorigin="anonymous"></audio>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chasing Sunset</title>
<style>
  :root{
    --hot-pink:#ff2e93;
    --cyan:#00f5ff;
    --acid:#39ff14;
    --ink:#0e0b2b;
  }
  html,body{
    height:100%; margin:0; background:#0a0014; overflow:hidden;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:white;
  }
  #wrap{
    position:fixed; inset:0; display:grid; place-items:center;
    z-index:1; /* canvas layer */
  }
  canvas{
    image-rendering: auto;
    box-shadow: 0 20px 60px #000 inset, 0 0 40px #ff2e9355, 0 0 80px #00f5ff33;
    border-radius: 12px;
    background:#120024;
  }
  /* Overlay exists but we render HUD in-canvas now */
  #overlay{
    position:fixed; inset:0; pointer-events:none;
    z-index:2; /* UI layer above canvas */
  }
  #title{ display:none; }
  #hud{ display:none; }
  #help{
    position:fixed; bottom:12px; width:100%; text-align:center; opacity:.8; font-size:12px;
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="480" height="270" aria-label="Chasing Sunset canvas game"></canvas>
</div>

<div id="overlay">
  <div id="title">Chasing Sunset</div>
  <div id="hud">Distance: 0  •  Hits: 0</div>
</div>

<!-- Background music (plays after first click/key). Using sidecar file to avoid data-URL truncation in the editor. -->
<audio id="bgm" preload="auto" loop src="bgm.mp3"></audio>

<script>
(() => {
  // ===============================
  // Build: v1.3 (bugfix HUD, lives/hearts, cats only)
  // ===============================

  // ---- basic setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = true;

  // ---- background music (starts on first interaction)
  (function(){
    const el = document.getElementById('bgm');
    if (!el) return;
    el.volume = 0.5;
    el.muted = false;
    // If the editor truncated an inline data URL (contains '...'), fall back to sidecar
    const src = el.getAttribute('src') || '';
    if (!src || (src.startsWith('data:audio') && src.includes('...'))){
      el.removeAttribute('src');
      el.src = 'bgm.mp3';
    }
    // Kick off playback on first user gesture (autoplay policy)
    const start = ()=>{ el.play().catch(()=>{}); };
    window.addEventListener('pointerdown', start, { once:true });
    window.addEventListener('keydown', start, { once:true });
  })();

  const W = canvas.width, H = canvas.height, cx = W/2;
  const horizonY = H * 0.45;
  const roadTopW = 44, roadBottomW = W * 0.92, LANES = 3;

  // Global speed scale (≈50% requested)
  const SPEED_SCALE = 0.5;

  // ---- debug overlay
  const DEBUG = { show:false, fps:0, frames:0, accum:0 };
  let lastDt = 0;

  // ---- game state
  const state = {
    time: 0,
    normalSpeed: 120, // world scroll speed (px/s)
    stopUntil: 0,
    distance: 0,
    hits: 0,
    lives: 4,          // start with 4 lives (hearts)
    gameOver: false,   // game over state flag
    restartAt: 0,      // when to auto-restart after game over
    highScores: []     // session top distances (max 3)
  };

  const obstacleSpeedFactor = 0.88;

  // Title & smoke
  const titleText = 'Chasing Sunset';
  let titleBox = null;
  const smoke = [];
  let smokeAcc = 0;
  const smokeRate = 26;

  // Player (wide + low)
  const playerY = H * 0.78;
  const player = {
    lane: 1,
    width: 74,
    height: 108,
    x() { return laneXAtY(this.lane, playerY); }
  };

  // Obstacles
  const obstacles = [];
  let nextSpawn = 1.2;

  // Palms
  const palms = [];
  function spawnPalm(side){ palms.push({ side, y: -Math.random()*H }); }
  for(let i=0;i<12;i++){ spawnPalm(-1); spawnPalm(1); }

  // ---- helpers
  const clamp = (v,a,b)=>v<a?a:v>b?b:v;
  const lerp = (a,b,t)=>a+(b-a)*t;

  function roadEdgesAtY(y){
    const t = clamp((y - horizonY) / (H - horizonY), 0, 1);
    const w = lerp(roadTopW, roadBottomW, t);
    return { left: cx - w/2, right: cx + w/2, width: w };
  }
  function laneXAtY(lane, y){
    const e = roadEdgesAtY(y);
    const third = e.width / LANES;
    return e.left + third*(lane + 0.5);
  }

  // ---- smoke
  function spawnSmokePuff(){
    if (!titleBox) return;
    const x = titleBox.left + Math.random()*titleBox.width;
    const y = titleBox.top - 2;
    smoke.push({ x, y, vx:(Math.random()-0.5)*14, vy:-(12+Math.random()*18), r:2+Math.random()*2, life:0, max:2.6+Math.random()*1.4 });
  }
  function updateSmoke(dt){
    const dts = dt * SPEED_SCALE;
    smokeAcc += smokeRate * dts;
    while (smokeAcc >= 1){ spawnSmokePuff(); smokeAcc -= 1; }
    for (let i = smoke.length - 1; i >= 0; i--) {
      const p = smoke[i];
      p.life += dts;
      p.x += p.vx * dts;
      p.y += p.vy * dts;
      p.vx *= 0.98;
      p.vy -= 6 * dts;
      p.r += dts * 10;
      if (p.life >= p.max) smoke.splice(i,1);
    }
  }
  function drawSmoke(){
    if (!smoke.length) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const p of smoke){
      const t = p.life / p.max;
      const alpha = (1 - t) * 0.35;
      const r = Math.max(1, p.r);
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
      grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
  // ---- impact poofs (particle burst)
  const poofs = [];
  function spawnPoof(x, y, s=1){
    const count = 26;
    for (let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const sp = 120 + Math.random()*220;
      poofs.push({
        x, y,
        vx: Math.cos(ang)*sp,
        vy: Math.sin(ang)*sp - 60,
        r: (2 + Math.random()*3) * (0.6 + s*0.4),
        life: 0,
        max: 0.7 + Math.random()*0.5,
        hue: Math.random() < 0.5 ? 330 : 190 // magenta or cyan
      });
    }
  }
  function updatePoofs(dt){
    for (let i=poofs.length-1; i>=0; i--){
      const p = poofs[i];
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.97;
      p.vy += 420 * dt; // gravity
      p.r *= 0.985;
      if (p.life > p.max) poofs.splice(i,1);
    }
  }
  function drawPoofs(){
    if (!poofs.length) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const p of poofs){
      const t = p.life / p.max;
      const a = (1 - t) * 0.8;
      const rad = Math.max(0.5, p.r);
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, rad);
      const col = p.hue === 330 ? `rgba(255,46,147,${a})` : `rgba(0,245,255,${a*0.85})`;
      g.addColorStop(0, col);
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(p.x, p.y, rad, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // ---- scenery
  function drawMountains(){
    ctx.save();
    const backGrad = ctx.createLinearGradient(0, horizonY-60, 0, horizonY);
    backGrad.addColorStop(0, '#0d1630'); backGrad.addColorStop(1, '#0a1a26');
    ctx.fillStyle = backGrad;
    ctx.beginPath(); ctx.moveTo(0, horizonY);
    for(let x=0;x<=W;x+=8){
      const y = horizonY - 22 - 16*Math.sin(x*0.03) - 10*Math.sin(x*0.115 + 1.7);
      ctx.lineTo(x,y);
    }
    ctx.lineTo(W, horizonY); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#5cf0ff'; ctx.globalAlpha = 0.25; ctx.lineWidth = 2; ctx.stroke();
    ctx.globalAlpha = 1;

    const frontGrad = ctx.createLinearGradient(0, horizonY-20, 0, horizonY+5);
    frontGrad.addColorStop(0, '#0d1f3f'); frontGrad.addColorStop(1, '#0b2233');
    ctx.fillStyle = frontGrad;
    ctx.beginPath(); ctx.moveTo(0, horizonY+2);
    for(let x=0;x<=W;x+=10){
      const y = horizonY - 8 - 10*Math.sin(x*0.05 + 0.5) - 6*Math.sin(x*0.14 + 2.1);
      ctx.lineTo(x,y);
    }
    ctx.lineTo(W, horizonY+2); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#00f5ff'; ctx.globalAlpha = 0.35; ctx.lineWidth = 2; ctx.stroke();
    ctx.restore();
  }

  // ---- input
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){
      player.lane = Math.max(0, player.lane - 1);
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){
      player.lane = Math.min(LANES-1, player.lane + 1);
    } else if (e.key === 'F2' || e.key === '`'){
      DEBUG.show = !DEBUG.show;
      e.preventDefault();
    }
  });
  window.addEventListener('touchstart', (e) => {
    const x = e.touches[0].clientX;
    if (x < window.innerWidth/2) player.lane = Math.max(0, player.lane-1);
    else player.lane = Math.min(LANES-1, player.lane+1);
  });

  // ---- spawning
  function spawnObstacle(){
    const lane = (Math.random() * LANES) | 0;
    const type = 'cat';
    obstacles.push({ lane, y: horizonY + 2, type, passed:false, flashT: 0 });
    nextSpawn = state.time + (3000 + Math.random()*2000) / 1000; // 3–5s
  }

  // ---- drawing background & title
  function drawTitleAndSmoke(sunY, sunR){
    const txt = titleText;
    const fs = Math.min(44, Math.max(22, Math.floor(W*0.085)));
    ctx.save();
    ctx.font = '900 ' + fs + 'px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';

    const titleY = (sunY - sunR) - 6;
    const m = ctx.measureText(txt);
    const ascent = m.actualBoundingBoxAscent || fs*0.72;
    const descent = m.actualBoundingBoxDescent || fs*0.28;
    const top = titleY - ascent;
    titleBox = { left: cx - m.width/2, top, width: m.width, height: ascent+descent };

    ctx.shadowColor = '#ff2e93'; ctx.shadowBlur = 12; ctx.lineWidth = 3; ctx.strokeStyle = '#ff2e93';
    ctx.strokeText(txt, cx, titleY);
    ctx.shadowBlur = 0; ctx.lineWidth = 1; ctx.strokeStyle = '#00f5ff88'; ctx.strokeText(txt, cx, titleY);

    const g = ctx.createLinearGradient(0, top, 0, top + titleBox.height);
    g.addColorStop(0, '#fff4cf'); g.addColorStop(1, '#ff6db3');
    ctx.fillStyle = g; ctx.fillText(txt, cx, titleY);

    drawSmoke();
    ctx.restore();
  }

  function drawBackground(){
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0.00, '#2a0036');
    g.addColorStop(0.35, '#5b006b');
    g.addColorStop(0.62, '#ff2e93');
    g.addColorStop(0.82, '#ffb36b');
    g.addColorStop(1.00, '#1b0033');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    const sunY = horizonY - 8, sunR = 62;
    const sunG = ctx.createRadialGradient(cx, sunY, 8, cx, sunY, sunR);
    sunG.addColorStop(0, '#fff0a8'); sunG.addColorStop(1, '#ff6d6d');
    ctx.fillStyle = sunG; ctx.beginPath(); ctx.arc(cx, sunY, sunR, 0, Math.PI*2); ctx.fill();

    ctx.save(); ctx.beginPath(); ctx.arc(cx, sunY, sunR, 0, Math.PI*2); ctx.clip();
    ctx.globalAlpha = 0.35;
    for(let y=-sunR; y<sunR; y+=4){
      const yy = sunY + y;
      ctx.fillStyle = (y % 8 === 0) ? '#ff2e93' : '#ff9c6b';
      ctx.fillRect(cx - sunR, yy, sunR*2, 2);
    }
    ctx.restore();

    drawMountains();
    drawTitleAndSmoke(sunY, sunR);

    const top = roadEdgesAtY(horizonY+1), bot = roadEdgesAtY(H);
    ctx.fillStyle = '#0f001a';
    ctx.beginPath();
    ctx.moveTo(top.left, horizonY);
    ctx.lineTo(top.right, horizonY);
    ctx.lineTo(bot.right, H);
    ctx.lineTo(bot.left, H);
    ctx.closePath(); ctx.fill();

    // Road edge glow
    ctx.save();
    ctx.shadowColor = '#ff2e93'; ctx.shadowBlur = 8; ctx.strokeStyle = '#ff2e93'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(top.left, horizonY); ctx.lineTo(bot.left, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(top.right, horizonY); ctx.lineTo(bot.right, H); ctx.stroke();
    ctx.restore();

    // Lane lines
    ctx.strokeStyle = '#ff2e93'; ctx.lineWidth = 2; ctx.globalAlpha = 0.9;
    for(let l=1; l<LANES; l++){
      ctx.beginPath();
      for(let y=horizonY; y<=H; y+=8){
        const e = roadEdgesAtY(y);
        const x = e.left + (e.width/LANES)*l;
        if (y === horizonY) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Perspective grid
    ctx.strokeStyle = '#00f5ff'; ctx.lineWidth = 1; ctx.globalAlpha = 0.42;
    for(let i=0;i<30;i++){
      const t = i/30;
      const y = lerp(horizonY, H, t*t);
      const e = roadEdgesAtY(y);
      ctx.beginPath(); ctx.moveTo(e.left, y); ctx.lineTo(e.right, y); ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // ---- player car (boxy rear to match reference)
  function drawPlayer(){
    const x = player.x(), y = playerY;
    const brakeOn = (state.time < state.stopUntil);
    const w = player.width, h = player.height;

    ctx.save();
    ctx.translate(x, y);

    // Ground shadow (tall SUV)
    ctx.globalAlpha = 0.32;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(0, h*0.60, w*0.62, 8, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // ============================
    // Volvo XC90-styled rear view
    // (more realistic, less neon)
    // ============================

    // Body shell (white to grey)
    let shell = ctx.createLinearGradient(0, -h*0.55, 0, h*0.40);
    shell.addColorStop(0, '#ffffff');
    shell.addColorStop(1, '#cfd6e0');
    ctx.fillStyle = shell;
    ctx.beginPath();
    ctx.moveTo(-w*0.62,  h*0.36); // bottom left bumper
    ctx.lineTo( w*0.62,  h*0.36); // bottom right bumper
    ctx.lineTo( w*0.66,  h*0.08); // shoulder
    ctx.lineTo( w*0.54, -h*0.06);
    ctx.lineTo( w*0.48, -h*0.18);
    ctx.lineTo(-w*0.48, -h*0.18);
    ctx.lineTo(-w*0.54, -h*0.06);
    ctx.lineTo(-w*0.66,  h*0.08);
    ctx.closePath();
    ctx.fill();

    // Subtle outline
    ctx.strokeStyle = '#4a5260';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Rear glass
    let glass = ctx.createLinearGradient(0, -h*0.22, 0, h*0.05);
    glass.addColorStop(0, '#0b1220');
    glass.addColorStop(1, '#1c2a3a');
    ctx.fillStyle = glass;
    const rw = w*0.82, rh = h*0.36;
    ctx.fillRect(-rw/2, -h*0.20, rw, rh);

    // High-mounted brake light (top center)
    if (brakeOn){
      const hbW = w*0.26, hbH = Math.max(3, h*0.02);
      const hbY = -h*0.26;
      const hbGrad = ctx.createLinearGradient(0, hbY - hbH, 0, hbY + hbH);
      hbGrad.addColorStop(0, '#ffd4da');
      hbGrad.addColorStop(1, '#ff0033');
      ctx.save();
      ctx.shadowColor = '#ff1a2f';
      ctx.shadowBlur = 12;
      ctx.fillStyle = hbGrad;
      ctx.fillRect(-hbW/2, hbY, hbW, hbH);
      ctx.restore();
    }

    // Rear wiper
    ctx.strokeStyle = '#aab6c6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-w*0.05, -h*0.02);
    ctx.lineTo(w*0.20,  -h*0.08);
    ctx.stroke();

    // Chrome trim + VOLVO badge
    let trim = ctx.createLinearGradient(0, 0, 0, h*0.07);
    trim.addColorStop(0, '#e7eef8');
    trim.addColorStop(1, '#a8bccf');
    ctx.fillStyle = trim;
    ctx.fillRect(-w*0.46, h*0.02, w*0.92, h*0.06);

    ctx.fillStyle = '#6b7d91';
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('VOLVO', 0, h*0.05);

    // Tail lights — sculpted XC90 shape with 20+ points
    function drawVolvoTailLight(side){
      const sgn = side < 0 ? -1 : 1; // -1 left, +1 right

      // Stronger taper so the top finishes inside the body outline
      const xOuterBot = (side < 0) ? -w*0.62 :  w*0.62;   // at bumper edge
      const xOuterTop = xOuterBot - sgn*(w*0.065);       // taper inward near roof
      const xInnerBot = xOuterBot - sgn*(w*0.125);       // inner edge near liftgate
      const xInnerTop = xOuterTop - sgn*(w*0.055);       // inner edge also tapers
      const xHook     = xOuterTop - sgn*(w*0.10);        // small inward top hook

      const yBot  =  h*0.30;
      const yMid  = -h*0.02;
      const yHook = -h*0.14;                              // hook sits below roof
      const yTop  = -h*0.18;                              // align with roof line of body

      const pts = [];
      // Outer edge upwards (14 steps) with taper
      for(let i=0;i<=13;i++){
        const t = i/13; pts.push([
          xOuterBot + (xOuterTop - xOuterBot)*t,
          yBot + (yTop - yBot)*t
        ]);
      }
      // Top hook sweep inward (8 steps)
      for(let i=1;i<=8;i++){
        const t = i/8; pts.push([
          xOuterTop + (xHook - xOuterTop)*t,
          yTop + (yHook - yTop)*t
        ]);
      }
      // Inner edge down: slim near top, widening toward bottom
      for(let i=1;i<=6;i++){
        const t = i/6; pts.push([ xInnerTop, yHook + (yMid - yHook)*t ]);
      }
      for(let i=1;i<=8;i++){
        const t = i/8; pts.push([
          xInnerTop + (xInnerBot - xInnerTop)*t,
          yMid + (yBot - yMid)*t
        ]);
      }

      // Fill
      const grad = ctx.createLinearGradient(0, yTop, 0, yBot);
      grad.addColorStop(0, brakeOn ? '#ffccd5' : '#ff9aab');
      grad.addColorStop(0.5, brakeOn ? '#ff2a3e' : '#ff2340');
      grad.addColorStop(1, brakeOn ? '#8e0018' : '#660010');

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath();
      ctx.fillStyle = grad; ctx.fill();

      // Clip the amber band to the light shape (stays inside contour)
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0][0], pts[0][1]);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath(); ctx.clip();
      const bandY = -h*0.02, bandH = h*0.07;
      ctx.fillStyle = '#ffbf3b';
      const bandLeft = Math.min(xOuterTop, xInnerTop);
      const bandW = Math.abs(xOuterTop - xInnerTop);
      ctx.fillRect(bandLeft, bandY, bandW, bandH);
      ctx.restore();

      // Outline
      ctx.lineWidth = 1.1; ctx.strokeStyle = '#4e0010'; ctx.stroke();
      ctx.restore();
    }

    // Ensure lights never render outside the body silhouette
    function clipBodyInterior(){
      ctx.beginPath();
      ctx.moveTo(-w*0.60,  h*0.34);
      ctx.lineTo( w*0.60,  h*0.34);
      ctx.lineTo( w*0.64,  h*0.08);
      ctx.lineTo( w*0.52, -h*0.06);
      ctx.lineTo( w*0.46, -h*0.18);
      ctx.lineTo(-w*0.46, -h*0.18);
      ctx.lineTo(-w*0.52, -h*0.06);
      ctx.lineTo(-w*0.64,  h*0.08);
      ctx.closePath();
      ctx.clip();
    }

    ctx.save();
    clipBodyInterior();
    drawVolvoTailLight(-1);
    drawVolvoTailLight( 1);
    ctx.restore();

    // Reverse lights inside bumper area
    ctx.fillStyle = '#eef6ff';
    ctx.fillRect(-w*0.18, h*0.16, w*0.14, h*0.06);
    ctx.fillRect( w*0.04,  h*0.16, w*0.14, h*0.06);

    // Number plate (neutral, moved up + label)
    let plate = ctx.createLinearGradient(0, h*0.10, 0, h*0.22);
    plate.addColorStop(0, '#f7fbff');
    plate.addColorStop(1, '#bcc8d6');
    ctx.fillStyle = plate;
    const plateY = h*0.08;        // moved upward to be centered under the chrome trim
    const plateH = h*0.10;
    const plateW = w*0.44;
    ctx.fillRect(-plateW/2, plateY, plateW, plateH);
    // Plate text
    ctx.fillStyle = '#111';
    ctx.font = 'bold ' + Math.max(10, Math.floor(plateH*0.65)) + 'px monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('420', 0, plateY + plateH/2);

    // Bumper & skid plate
    ctx.fillStyle = '#1c2734';
    ctx.fillRect(-w*0.62, h*0.26, w*1.24, h*0.12);

    let skid = ctx.createLinearGradient(0, h*0.30, 0, h*0.42);
    skid.addColorStop(0, '#d7dde6');
    skid.addColorStop(1, '#7a8796');
    ctx.fillStyle = skid;
    ctx.fillRect(-w*0.52, h*0.32, w*1.04, h*0.10);

    // Exhaust (left only)
    ctx.fillStyle = '#3a424c';
    ctx.beginPath(); ctx.ellipse(-w*0.28, h*0.40, 5, 3.4, 0, 0, Math.PI*2); ctx.fill();

    // Subtle underglow
    let ug = ctx.createRadialGradient(0, h*0.52, 2, 0, h*0.52, w*0.80);
    ug.addColorStop(0, 'rgba(0,245,255,0.18)');
    ug.addColorStop(1, 'rgba(0,245,255,0)');
    ctx.fillStyle = ug;
    ctx.beginPath(); ctx.ellipse(0, h*0.52, w*0.86, 12, 0, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  // ---- cat sprite
  function drawCatSprite(){
    const w = 28, h = 18 * 1.3;

    // Shadow
    ctx.globalAlpha = 0.28; ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.ellipse(0, h*0.42, w*0.55, 3.5, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    // Body
    ctx.fillStyle = '#0c0f1e';
    ctx.beginPath(); ctx.ellipse(0, 0, w*0.58, h*0.36, 0, 0, Math.PI*2); ctx.fill();

    // Head
    const hx = -w*0.52, hy = -h*0.10, hr = h*0.38;
    ctx.beginPath(); ctx.arc(hx, hy, hr, 0, Math.PI*2); ctx.fill();

    // Ears
    ctx.beginPath();
    ctx.moveTo(hx - hr*0.62, hy - hr*0.35);
    ctx.lineTo(hx - hr*0.28, hy - hr*1.0);
    ctx.lineTo(hx - hr*0.02, hy - hr*0.35);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(hx + hr*0.08, hy - hr*0.30);
    ctx.lineTo(hx + hr*0.38, hy - hr*0.95);
    ctx.lineTo(hx + hr*0.56, hy - hr*0.25);
    ctx.closePath(); ctx.fill();

    // Legs
    for (const lx of [-w*0.35, -w*0.10, w*0.12, w*0.36]){
      ctx.beginPath(); ctx.ellipse(lx, h*0.28, Math.max(2, w*0.09), 3, 0, 0, Math.PI*2); ctx.fill();
    }

    // Tail
    const wag = Math.sin(state.time * 2) * h * 0.04;
    ctx.strokeStyle = '#39ff14'; ctx.lineWidth = 2; ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.moveTo(w*0.55, -h*0.05);
    ctx.quadraticCurveTo(w*0.86, -h*0.38 + wag, w*0.48, -h*0.56 + wag);
    ctx.quadraticCurveTo(w*0.28, -h*0.70 + wag, w*0.40, -h*0.24 + wag*0.6);
    ctx.stroke(); ctx.globalAlpha = 1;

    // Eyes
    const eyeOffset = hr*0.36, eyeY = hy + hr*0.02;
    for (const ex of [hx - eyeOffset, hx + eyeOffset*0.25]){
      const grad = ctx.createRadialGradient(ex, eyeY, 0.1, ex, eyeY, 3);
      grad.addColorStop(0, 'rgba(170,255,68,0.9)');
      grad.addColorStop(1, 'rgba(170,255,68,0)');
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(ex, eyeY, 3, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#caff59'; ctx.beginPath(); ctx.ellipse(ex, eyeY, 2.2, 1.5, 0, 0, Math.PI*2); ctx.fill();
    }

    // Whiskers + neon outline
    ctx.strokeStyle = '#b7dfff'; ctx.lineWidth = 1;
    for(let i=-1;i<=1;i++){
      const yy = hy + i*3;
      ctx.beginPath(); ctx.moveTo(hx - 2, yy); ctx.lineTo(hx - 20, yy - 1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(hx + 2, yy); ctx.lineTo(hx + 18, yy - 1); ctx.stroke();
    }
    ctx.strokeStyle = '#39ff14'; ctx.lineWidth = 2; ctx.globalAlpha = 0.9;
    ctx.beginPath(); ctx.ellipse(0, 0, w*0.58, h*0.36, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(hx, hy, hr, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha = 1;
  }

  // ---- obstacles
  function drawObstacle(o){
    if (o.flying){
      ctx.save();
      ctx.translate(o.fx ?? 0, o.fy ?? 0);
      if (o.rot) ctx.rotate(o.rot);
      const s = o.fs ?? 1;
      ctx.scale(s, s);
      drawCatSprite();
      ctx.restore();
      return;
    }
    const y = o.y; const x = laneXAtY(o.lane, y);
    ctx.save(); ctx.translate(x, y);
    const t = clamp((y - horizonY) / (H - horizonY), 0, 1);
    const s = clamp(lerp(0.25, 1.1, t), 0.25, 1.1);
    ctx.scale(s, s);

    drawCatSprite();
    ctx.restore();
  }

  function collide(o){
    // Only collide in the same lane
    if (o.lane !== player.lane) return false;

    // Gate: obstacle must be at least 80% of the way from the horizon *to the car*,
    // not 80% of the entire road depth (the car sits around ~60%).
    const gateY = horizonY + 0.80 * (playerY - horizonY);
    if (o.y < gateY) return false;

    // Tighter vertical hit zone so the taller SUV doesn't over-collide
    const hitZone = 28; // pixels around playerY
    return Math.abs(o.y - playerY) < hitZone;
  }

  function resetGame(){
    // Reset run state
    state.distance = 0;
    state.hits = 0;
    state.lives = 4;
    state.gameOver = false;
    state.stopUntil = 0;
    obstacles.length = 0;
    nextSpawn = state.time + 1.2;
  }

  function addHighScore(d){
    const v = Math.max(0, Math.floor(d));
    state.highScores.push(v);
    state.highScores.sort((a,b)=>b-a);
    if (state.highScores.length > 3) state.highScores.length = 3;
  }

  // ---- canvas HUD + dev overlay
  function drawCanvasHUD(){
    const distText = `Distance: ${Math.floor(state.distance)}`;
    const label = 'Life:';
    const heartsTotal = 4;
    const heartsLeft = clamp(state.lives, 0, heartsTotal);

    // helper: heart
    function drawHeart(hx, hy, s, filled){
      ctx.save();
      if (filled){ ctx.shadowColor = '#ff2e93'; ctx.shadowBlur = 6; }
      ctx.beginPath();
      ctx.moveTo(hx, hy + s*0.6);
      ctx.bezierCurveTo(hx - s*1.2, hy + s*0.2, hx - s*1.2, hy - s*0.6, hx, hy - s*0.1);
      ctx.bezierCurveTo(hx + s*1.2, hy - s*0.6, hx + s*1.2, hy + s*0.2, hx, hy + s*0.6);
      if (filled){
        const gr = ctx.createLinearGradient(0, hy - s, 0, hy + s);
        gr.addColorStop(0,'#ff9ac5'); gr.addColorStop(1,'#ff2e93');
        ctx.fillStyle = gr; ctx.fill();
      }
      ctx.shadowBlur = 0;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = filled ? '#ff2e93' : '#ff2e93aa';
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.font = 'bold 14px monospace';
    ctx.textAlign = 'left'; ctx.textBaseline = 'top';

    const padding = 6, lineH = 16;
    const s = 6, gap = 10;
    const labelW = ctx.measureText(label).width;
    const heartsW = heartsTotal * (s*2 + gap) - gap; // approximate row width
    const row2W = labelW + 8 + heartsW;
    const row1W = ctx.measureText(distText).width;
    const boxW = Math.ceil(Math.max(row1W, row2W)) + padding*2;
    const boxH = lineH*2 + padding*2;
    const x = W - boxW - 8;
    let y = 8;
    if (titleBox) {
      y = Math.max(8, Math.round(titleBox.top + titleBox.height + 12));
    }
    y = clamp(y, 8, H - boxH - 8);

    // Panel
    ctx.globalAlpha = 0.85; ctx.fillStyle = '#00000066';
    ctx.fillRect(x, y, boxW, boxH); ctx.globalAlpha = 1;

    // Neon border
    ctx.shadowColor = '#00f5ff'; ctx.shadowBlur = 6;
    ctx.strokeStyle = '#00f5ff88'; ctx.lineWidth = 1.5;
    ctx.strokeRect(x + 0.5, y + 0.5, boxW - 1, boxH - 1);
    ctx.shadowBlur = 0;

    // Text row 1
    ctx.fillStyle = '#ffffff';
    ctx.fillText(distText, x + padding, y + padding);

    // Row 2: Life + hearts
    const y2 = y + padding + lineH;
    ctx.fillText(label, x + padding, y2);
    let hx = x + padding + labelW + 8 + s; // center of first heart
    for (let i=0;i<heartsTotal;i++){
      drawHeart(hx, y2 + 8, s, i < heartsLeft);
      hx += (s*2 + gap);
    }

    ctx.restore();
  }

  function drawHighScoresHUD(){
    const title = 'High Scores';
    const labels = ['#1', '#2', '#3'];
    const hs = state.highScores;
    const rows = [
      (hs[0] != null ? String(Math.floor(hs[0])) : '-----'),
      (hs[1] != null ? String(Math.floor(hs[1])) : '-----'),
      (hs[2] != null ? String(Math.floor(hs[2])) : '-----')
    ];

    ctx.save();
    ctx.font = 'bold 14px monospace';
    ctx.textAlign = 'left'; ctx.textBaseline = 'top';

    const padding = 6, lineH = 16;
    const titleW = ctx.measureText(title).width;
    let maxRowW = 0;
    for (let i=0;i<3;i++){
      const w = ctx.measureText(labels[i] + '  ' + rows[i]).width;
      if (w > maxRowW) maxRowW = w;
    }
    const boxW = Math.ceil(Math.max(titleW, maxRowW)) + padding*2;
    const boxH = lineH*4 + padding*2; // title + 3 rows
    const x = 8;
    let y = 8;
    if (titleBox) {
      y = Math.max(8, Math.round(titleBox.top + titleBox.height + 12));
    }
    y = clamp(y, 8, H - boxH - 8);

    // Panel
    ctx.globalAlpha = 0.85; ctx.fillStyle = '#00000066';
    ctx.fillRect(x, y, boxW, boxH); ctx.globalAlpha = 1;

    // Neon border (mirror HUD style)
    ctx.shadowColor = '#00f5ff'; ctx.shadowBlur = 6;
    ctx.strokeStyle = '#00f5ff88'; ctx.lineWidth = 1.5;
    ctx.strokeRect(x + 0.5, y + 0.5, boxW - 1, boxH - 1);
    ctx.shadowBlur = 0;

    // Content
    ctx.fillStyle = '#ffffff';
    ctx.fillText(title, x + padding, y + padding);
    for (let i=0;i<3;i++){
      ctx.fillText(labels[i] + '  ' + rows[i], x + padding, y + padding + (i+1)*lineH);
    }

    ctx.restore();
  }

  function drawDevOverlay(){
    if (!DEBUG.show) return;
    const moving = (state.time < state.stopUntil ? 0 : state.normalSpeed * SPEED_SCALE);
    const lines = [
      `FPS: ${DEBUG.fps}`,
      `dt: ${(lastDt*1000).toFixed(1)} ms`,
      `obstacles: ${obstacles.length}`,
      `world: ${moving.toFixed(1)} px/s`,
      `scale: ${SPEED_SCALE}`,
      `next spawn: ${Math.max(0, nextSpawn - state.time).toFixed(1)} s`,
      `build: v1.3`
    ];
    ctx.save();
    ctx.font = 'bold 12px monospace'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
    const pad = 6, lineH = 14;
    let w = 0; for (const s of lines) w = Math.max(w, ctx.measureText(s).width);
    const boxW = Math.ceil(w) + pad*2;
    const boxH = lineH*lines.length + pad*2;
    const x = 8, y = 8;

    ctx.globalAlpha = 0.85; ctx.fillStyle = '#00000066'; ctx.fillRect(x, y, boxW, boxH); ctx.globalAlpha = 1;
    ctx.shadowColor = '#ff2e93'; ctx.shadowBlur = 6; ctx.strokeStyle = '#ff2e93aa'; ctx.lineWidth = 1.5;
    ctx.strokeRect(x + 0.5, y + 0.5, boxW - 1, boxH - 1); ctx.shadowBlur = 0;

    ctx.fillStyle = '#ffffff';
    for (let i=0;i<lines.length;i++) ctx.fillText(lines[i], x + pad, y + pad + i*lineH);
    ctx.restore();
  }

  // ---- update & draw
  function update(dt){
    state.time += dt;
    updateSmoke(dt);

    // Impact poofs
    updatePoofs(dt);

    if (!state.gameOver && state.time >= nextSpawn) spawnObstacle();

    const moving = (state.gameOver || state.time < state.stopUntil) ? 0 : state.normalSpeed * SPEED_SCALE;

    palms.forEach(p => {
      p.y += moving * dt * 0.8;
      if (p.y > H+64) p.y = -Math.random()*H;
    });

    obstacles.forEach(o => {
      if (o.flying) {
        // Continue animating even if world is stopped (gameOver)
        o.vy = (o.vy ?? 0) + (o.gravity ?? 220) * dt;
        o.fx += (o.vx ?? 0) * dt;
        o.fy += (o.vy ?? 0) * dt;
        if (o.rvel) { o.rot = (o.rot || 0) + o.rvel * dt; }
        if (o.fs) o.fs *= 0.995; // slight shrink
      } else {
        const t = clamp((o.y - horizonY) / (H - horizonY), 0, 1);
        const earlyScale = t < 0.5 ? (0.4 + 1.2 * t) : 1.0; // slow first half
        o.y += moving * dt * obstacleSpeedFactor * earlyScale;
      }
    });

    state.distance += moving * dt / 10;

    if (moving > 0){
      for (const o of obstacles){
        if (!o.passed && collide(o)){
          o.passed = true;
          state.hits++;
          if (state.lives > 0) state.lives--;
          if (state.lives <= 0 && !state.gameOver){
            // Prepare the hit cat to fly off-screen in a random direction
            const yHit = o.y;
            const xHit = laneXAtY(o.lane, yHit);
            const tScale = clamp((yHit - horizonY) / (H - horizonY), 0, 1);
            const sScale = clamp(lerp(0.25, 1.1, tScale), 0.25, 1.1);
            o.flying = true;
            o.fx = xHit; o.fy = yHit; o.fs = sScale; o.rot = 0;
            o.vx = (Math.random() < 0.5 ? -1 : 1) * (160 + Math.random()*140);
            o.vy = -(140 + Math.random()*180);
            o.rvel = (Math.random()*2 - 1) * 6; // spin
            o.gravity = 300;

            // Impact burst
            spawnPoof(xHit, yHit, sScale);

            // Trigger game over and schedule restart in 3s
            addHighScore(state.distance);
            state.gameOver = true;
            state.restartAt = state.time + 3.0;
            state.stopUntil = 0; // ignore normal hit stop
          } else {
            // Hit but still have lives: fling the cat too
            const yHit = o.y;
            const xHit = laneXAtY(o.lane, yHit);
            const tScale = clamp((yHit - horizonY) / (H - horizonY), 0, 1);
            const sScale = clamp(lerp(0.25, 1.1, tScale), 0.25, 1.1);
            o.flying = true;
            o.fx = xHit; o.fy = yHit; o.fs = sScale; o.rot = 0;
            o.vx = (Math.random() < 0.5 ? -1 : 1) * (140 + Math.random()*120);
            o.vy = -(120 + Math.random()*160);
            o.rvel = (Math.random()*2 - 1) * 6; // spin
            o.gravity = 300;

            // Impact burst
            spawnPoof(xHit, yHit, sScale);

            // Brief stop on hit
            state.stopUntil = state.time + 2.0;
          }
          break;
        }
      }
    }

    // Cleanup obstacles off-screen
    for (let i=obstacles.length-1; i>=0; i--){
      const o = obstacles[i];
      if (o.flying){
        if (o.fx < -64 || o.fx > W + 64 || o.fy < -64 || o.fy > H + 64) {
          obstacles.splice(i,1);
        }
      } else if (o.y > H + 64) {
        obstacles.splice(i,1);
      }
    }

    // Auto-restart after 3 seconds of game over
    if (state.gameOver && state.time >= state.restartAt) {
      resetGame();
    }
  }

  function draw(){
    drawBackground();

    palms.forEach(p => drawPalm(p.y, p.side));
    drawPlayer();
    obstacles.forEach(drawObstacle);
    // Draw particle bursts above obstacles
    drawPoofs();

    drawCanvasHUD();
    drawHighScoresHUD();
    drawDevOverlay();

    if (state.gameOver){
      ctx.save();
      const msg = 'GAME OVER';

      // Make the text at least 1/3 of the canvas height and fit to width if needed
      let fs = Math.floor(H / 3);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '900 ' + fs + 'px monospace';
      let m = ctx.measureText(msg);
      if (m.width > W * 0.92) {
        fs = Math.floor(fs * (W * 0.92 / m.width));
        ctx.font = '900 ' + fs + 'px monospace';
      }

      // Stronger red with neon glow and gradient
      const blink = (Math.sin(state.time * 5) > 0) ? 1.0 : 0.75;
      ctx.globalAlpha = blink;
      ctx.shadowColor = '#ff0022';
      ctx.shadowBlur = Math.max(12, Math.floor(fs * 0.2));
      const grad = ctx.createLinearGradient(0, (H/2) - fs*0.6, 0, (H/2) + fs*0.6);
      grad.addColorStop(0, '#ffd1d6');
      grad.addColorStop(0.35, '#ff3350');
      grad.addColorStop(1, '#a40014');
      ctx.fillStyle = grad;
      ctx.fillText(msg, cx, H * 0.5);

      // Dark outline for readability
      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(3, Math.floor(fs * 0.065));
      ctx.strokeStyle = '#51000c';
      ctx.strokeText(msg, cx, H * 0.5);

      ctx.restore();
    } else if (state.time < state.stopUntil){
      ctx.save();

      // Bigger, lower, and more vibrant hit message
      const msg = "Don't hit the Shmee!";

      // 4× bigger than before (16px → 64px) with auto width fit
      let fs = 64;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '900 ' + fs + 'px monospace';
      let metrics = ctx.measureText(msg);
      if (metrics.width > W * 0.95) {
        fs = Math.floor(fs * (W * 0.95 / metrics.width));
        ctx.font = '900 ' + fs + 'px monospace';
      }

      // Move ~1/3 screen lower from previous ~0.34H -> ~0.67H
      const y = Math.min(H - fs, H * 0.67);

      // Neon red/magenta gradient + glow for vibrancy
      const grad = ctx.createLinearGradient(0, y - fs*0.6, 0, y + fs*0.6);
      grad.addColorStop(0, '#ffe5ff');
      grad.addColorStop(0.4, '#ff2e93');
      grad.addColorStop(1, '#ff0033');

      ctx.globalAlpha = 1;
      ctx.shadowColor = '#ff0033';
      ctx.shadowBlur = Math.max(12, Math.floor(fs * 0.25));
      ctx.fillStyle = grad;
      ctx.fillText(msg, cx, y);

      // Dark outline for contrast
      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(3, Math.floor(fs * 0.06));
      ctx.strokeStyle = '#220011';
      ctx.strokeText(msg, cx, y);

      ctx.restore();
    }
  }

  function drawPalm(y, side){
    if (y < horizonY-6 || y > H+60) return;
    const e = roadEdgesAtY(y);
    const x = side < 0 ? e.left - 14 : e.right + 14;
    const t = clamp((y - horizonY) / (H - horizonY), 0, 1);
    const s = clamp(lerp(0.22, 1.45, t), 0.22, 1.45);

    ctx.fillStyle = '#00f5ff';
    ctx.fillRect(x - 2, y - 40*s, 4, 40*s);

    ctx.fillStyle = '#39ff14';
    const fr = 9*s;
    for(let i=0;i<5;i++){
      const ang = (-0.9 + i*0.45) * (side<0?1:-1);
      ctx.beginPath();
      ctx.moveTo(x, y - 40*s);
      ctx.lineTo(x + Math.cos(ang)*fr, y - 40*s + Math.sin(ang)*fr);
      ctx.lineTo(x + Math.cos(ang)*fr*1.7, y - 40*s + Math.sin(ang)*fr*1.15);
      ctx.closePath(); ctx.fill();
    }
  }

  // ---- main loop
  let last = 0;
  function loop(t){
    const now = t/1000;
    const dt = Math.min(0.033, (last ? now - last : 0));
    last = now;

    lastDt = dt;
    DEBUG.accum += dt; DEBUG.frames += 1;
    if (DEBUG.accum >= 0.25){
      DEBUG.fps = Math.round(DEBUG.frames / DEBUG.accum);
      DEBUG.frames = 0; DEBUG.accum = 0;
    }

    update(dt);
    ctx.clearRect(0,0,W,H);
    draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Fit to window
  function fit(){
    const ww = window.innerWidth, wh = window.innerHeight;
    const s = Math.min(ww / W, wh / H);
    canvas.style.width = Math.floor(W * s) + 'px';
    canvas.style.height = Math.floor(H * s) + 'px';
  }
  window.addEventListener('resize', fit); fit();

  // --------------------
  // Minimal sanity tests
  // --------------------
  function runSanityTests(){
    console.assert(canvas && ctx, 'Canvas/Context should exist');
    console.assert(typeof drawCanvasHUD === 'function', 'drawCanvasHUD should be a function');
    console.assert(typeof spawnObstacle === 'function', 'spawnObstacle exists');
    const before = obstacles.length; spawnObstacle();
    console.assert(obstacles.length === before + 1, 'spawnObstacle should push one obstacle');
    console.assert(obstacles[obstacles.length-1].type === 'cat', 'obstacle type should be cat');
    // Reset so gameplay unaffected
    obstacles.pop();
    // High score sorting & trimming
    const savedHS = state.highScores.slice();
    state.highScores.length = 0;
    addHighScore(100); addHighScore(300); addHighScore(200); addHighScore(400);
    console.assert(state.highScores.length === 3, 'highScores keeps top 3');
    console.assert(state.highScores[0] === 400 && state.highScores[1] === 300 && state.highScores[2] === 200, 'highScores sorted desc');
    // New: audio element present & configured
    const bgm = document.getElementById('bgm');
    console.assert(!!bgm, 'bgm <audio> should exist');
    console.assert(bgm.hasAttribute('loop'), 'bgm should loop');
    console.assert(bgm.getAttribute('preload') === 'auto', 'bgm should preload=auto');
    // restore
    state.highScores = savedHS;
  }
  runSanityTests();
})();
</script>
</body>
</html>
